<!DOCTYPE html>
<html lang="en">
<head>
<title>Ember.js - A JavaScript Application Framework</title>
<link rel=stylesheet href=styles/style.css />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27488933-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<body>
<div id="wrap">
<div id="about">
  <div id="logo">&nbsp;</div>
  <p>
    Ember is a JavaScript framework that helps developers be more productive by eliminating boilerplate and providing a strong MVC architecture.
  </p>
  <a class="button">download</a>
  <ul id="nav">
    <li><a href="index.html">tutorial</a></li>
    <li class="active"><a href="/docs.html">docs</a></li>
  </ul>
</div>

<div id="content">
 <!--div class="section">
  <h2>describing your ui with handlebars</h2>
  <h3>this is a sub head</h3>
  <p>chut up tom</p>
 </div>-->

 <h1>Ember.js Guide</h1>
<div class="section">
 <h2>Introduction</h2>

 <h3>What is Ember.js?</h3>

 <p>Ember is a JavaScript framework that helps developers be more productive
 by eliminating boilerplate and providing a strong MVC architecture.</p>

 <h4>Eliminate Boilerplate</h4>

 <p>There are some tasks that are common to every web application. For example,
 taking data from the server, rendering it to the screen, then updating that
 information when it changes.</p>

 <p>Since the tools provided to do this by the browser are quite primitive, you
 end up writing the same code over and over. Ember.js provides tools that let
 you focus on your app instead of writing the same code you&rsquo;ve written a hundred
 times.</p>

 <p>Because we&rsquo;ve built dozens of applications ourselves, we&rsquo;ve gone beyond the
 obvious low-level event-driven abstractions, eliminating much of the
 boilerplate associated with propagating changes throughout your application,
 and especially into the DOM itself.</p>

 <p>To help manage changes in the view, Ember.js comes with a templating engine
 that will automatically update the DOM when the underlying objects change.</p>

 <p>For a simple example, consider this template of a Person:</p>

 <pre><code>{{person.name}} is {{person.age}}.
 </code></pre>

 <p>Obviously, when the template is initially rendered, it will reflect the
 current state of the person. To avoid boilerplate, Ember.js will also
 update the view automatically for you if the person&rsquo;s name or age changes.</p>

 <p>You specify your template once, and we make sure it&rsquo;s always up to date.</p>

 <h4>Provides Architecture</h4>

 <p>Since web applications evolved from web pages, which were nothing more than
 static documents, browsers give you just enough rope to hang yourself with.</p>

 <p>Ember makes it easy to divide your application into models, views, and controllers,
 which improves testability, makes code more modular, and helps new developers
 on the project quickly understand how everything fits together. The days of
 callback spaghetti are over.</p>

 <p>Ember also supplies built-in support for state management, so you&rsquo;ll have
 a way to describe how your application moves through various nested states
 (like logged out, logged in, viewing post, viewing comment) out of the box.</p>

 <p><we will eventually want a paragraph about data here></p>

 <h3>How is Ember.js Different from Server-Side Frameworks?</h3>

 <p>Traditional web applications make the user to download a new page every time
 they interact with the server. This means that every interaction is never faster
 than the latency between you and the user, and usually slower. Using Ajax to
 replace only parts of the page helps somewhat, but still requires a roundtrip to
 your server every time your UI needs to update. And if multiple parts of the
 page need to update all at once, most developers just resort to loading the page
 over again, since keeping everything in sync is tricky.</p>

 <p>Ember.js, like some other modern JavaScript frameworks, works a little differently.
 Instead of the majority of your application&rsquo;s logic living on the server, an
 Ember.js application downloads everything it needs to run in the initial page
 load. That means that while your user is using your app, they never have to load
 a new page and your UI responds quickly to their interaction.</p>

 <p>One advantage of this architecture is that your web application uses the same
 REST API as your native apps or third-party clients. Back-end developers can
 focus on building a fast, reliable and secure API server and don&rsquo;t have to be
 front-end experts, too.</p>

 <h3>Ember.js at a Glance</h3>

 <p>These are the three features that make Ember a joy to use:</p>

 <ol>
 <li>Bindings</li>
 <li>Computed properties</li>
 <li>Auto-updating templates</li>
 </ol>


 <h4>Bindings</h4>

 <p>Use bindings to keep properties between two different objects in sync. You just
 declare a binding once, and Ember will make sure changes get propagated in either
 direction.</p>

 <p>Here&rsquo;s how you create a binding between two objects:</p>

 <pre><code>MyApp.president = SC.Object.create({
   name: "Barack Obama"
 });

 MyApp.country = SC.Object.create({
   // Ending a property with 'Binding' tells SproutCore to
   // create a binding to the presidentName property.
   presidentNameBinding: 'MyApp.president.name'
 });

 MyApp.country.get('presidentName');
 // "Barack Obama"
 </code></pre>

 <p>Bindings allow you to architect your application using the MVC (Model-View-Controller)
 pattern, then rest easy knowing that data will always flow correctly from layer to layer.</p>

 <h4>Computed Properties</h4>

 <p>Computed properties allow you to treat a function like a property:</p>

 <pre><code>MyApp.president = SC.Object.create({
   firstName: "Barack",
   lastName: "Obama",

   fullName: function() {
     return this.get('firstName') + ' ' + this.get('lastName');

     // Call this flag to mark the function as a property
   }.property()
 });

 MyApp.president.get('fullName');
 // "Barack Obama"
 </code></pre>

 <p>Treating a function like a property is useful because they can work with bindings, just
 like any other property.</p>

 <p>Many computed properties have dependencies on other properties. For example, in the above
 example, the <code>fullName</code> property depends on <code>firstName</code> and <code>lastName</code> to determine its value.
 You can tell Ember about these dependencies like this:</p>

 <pre><code>MyApp.president = SC.Object.create({
   firstName: "Barack",
   lastName: "Obama",

   fullName: function() {
     return this.get('firstName') + ' ' + this.get('lastName');

     // Tell SproutCore that this computed property depends on firstName
     // and lastName
   }.property('firstName', 'lastName')
 });
 </code></pre>

 <p>Make sure you list these dependencies so Ember knows when to update bindings that connect
 to a computed property.</p>
</div>
<div class="section">
 <h2>Auto-updating Templates</h2>

 <p>Ember uses Handlebars, a semantic templating library. To take data from your JavaScript application
 and put it into the DOM, create a <code>&lt;script&gt;</code> tag and put it into your HTML, wherever you&rsquo;d like the
 value to appear:</p>

 <pre><code>&lt;script type="text/x-handlebars"&gt;
   The President of the United States is {{MyApp.president.fullName}}.
 &lt;/script&gt;
 </code></pre>

 <p>Here&rsquo;s the best part: templates are bindings-aware. That means that if you ever change the value of
 the property that you told us to display, we&rsquo;ll update it for you automatically. And because you&rsquo;ve
 specified dependencies, changes to <em>those</em> properties are reflected as well.</p>

 <p>Hopefully you can see how all three of these powerful tools work together: start with some primitive
 properties, then start building up more sophisticated properties and their dependencies using computed
 properties. Once you&rsquo;ve described the data, you only have to say how it gets displayed once, and Ember
 takes care of the rest. It doesn&rsquo;t matter how the underlying data changes, whether from an XHR request
 or the user performing an action; your user interface always stays up-to-date. This eliminates entire
 categories of edge cases that developers struggle with every day.</p>

 <ol>
 <li>  Understanding MVC Architecture</li>
 <li><pre><code>What is MVC?
 </code></pre></li>
 <li><pre><code>The Model Layer
 </code></pre></li>
 <li><pre><code>The View Layer
 </code></pre></li>
 <li><pre><code>The Controller Layer
 </code></pre></li>
 <li><pre><code>Augmenting Controllers with Storyboards
 </code></pre></li>
 </ol>

</div>


<div class="section">
 <h2>The Ember Object Model</h2>

 <p>Ember enhances the simple JavaScript object model to support bindings
 and observers, as well as to support a more powerful mixin-based
 approach to code sharing.</p>

 <p>At its most basic, you create a new Ember class by using the <code>extend</code>
 method on <code>SC.Object</code>.</p>

 <pre><code>Person = SC.Object.extend({
   say: function(thing) {
     alert(thing);
   }
 });
 </code></pre>

 <p>Once you have built a new class, you can create new instances of the
 class by using the <code>create</code> method. Any properties defined on the class
 will be available to instances.</p>

 <pre><code>var person = Person.create();
 person.say("Hello") // alerts "Hello"
 </code></pre>

 <p>When creating an instance, you can also add additional properties to the
 class by passing in an object.</p>

 <pre><code>var tom = Person.create({
   name: "Tom Dale",

   helloWorld: function() {
     alert("Hi my name is " + this.get('name'));
   }
 });

 tom.helloWorld() // alerts "Hi my name is Tom Dale"
 </code></pre>

 <p>Because of Ember&rsquo;s support for bindings and observers, you will always
 access properties using the <code>get</code> method, and set properties using the
 <code>set</code> method.</p>

 <p>When creating a new instance of an object, you can also override any
 properties or methods defined on the class. For instance, in this case,
 you could override the <code>say</code> method from the <code>Person</code> class.</p>

 <pre><code>var yehuda = Person.create({
   name: "Yehuda Katz",

   say: function(thing) {
     var name = this.get('name');

     this._super(name + " says: " + thing);
   }
 });
 </code></pre>

 <p>You can use the <code>_super</code> method on the object (<code>super</code> is a reserved
 word in JavaScript) to call the original method you overrode.</p>

 <h3>Subclassing Classes</h3>

 <p>You can also create subclasses of classes you create by using the
 <code>extend</code> method. In fact, when we created a new class above by calling
 <code>extend</code> on <code>SC.Object</code>, we were <strong>subclassing</strong> <code>SC.Object</code>.</p>

 <pre><code>var LoudPerson = Person.extend({
   say: function(thing) {
     this._super(thing.toUpperCase());
   }
 });
 </code></pre>

 <p>When subclassing, you can use <code>this._super</code> to invoke methods you are
 overriding.</p>

 <h3>Reopening Classes</h3>

 <p>You don&rsquo;t need to define a class all at once. You can reopen a class and
 define new properties using the <code>reopenClass</code> method.</p>

 <pre><code>Person.reopenClass({
   isPerson: true
 });

 Person.create().get('isPerson') // true
 </code></pre>

 <p>When using <code>reopenClass</code>, you can also override existing methods and
 call <code>this._super</code>.</p>

 <pre><code>Person.reopenClass({
   // override `say` to add an ! at the end
   say: function(thing) {
     this._super(thing + "!");
   }
 });
 </code></pre>

 <h3>Computed Properties (Getters)</h3>

 <p>Often, you will want a property that is computed based on other
 properties. Ember&rsquo;s object model allows you to define computed
 properties easily in a normal class definition.</p>

 <pre><code>Person = SC.Object.extend({
   // these will be supplied by `create`
   firstName: null,
   lastName: null,

   fullName: function() {
     var firstName = this.get('firstName');
     var lastName = this.get('lastName');

     return firstName + ' ' + lastName;
   }.property('firstName', 'lastName')
 });

 var tom = Person.create({
   firstName: "Tom",
   lastName: "Dale"
 })

 tom.get('fullName') // "Tom Dale"
 </code></pre>

 <p>If you aren&rsquo;t using Ember&rsquo;s prototype extension, you can use a slightly
 more verbose version, wrapping the function in a call to <code>SC.computed</code>:</p>

 <pre><code>Person = SC.Object.extend({
   // these will be supplied by `create`
   firstName: null,
   lastName: null,

   fullName: SC.computed(function() {
     var firstName = this.get('firstName');
     var lastName = this.get('lastName');

     return firstName + ' ' + lastName;
   }).property('firstName', 'lastName')
 });
 </code></pre>

 <p>The <code>property</code> method defines the function as a computed property, and
 defines its dependencies. Those dependencies will come into play later
 when we discuss bindings and observers.</p>

 <p>When subclassing a class or creating a new instance, you can override
 any computed properties.</p>

 <h3>Computed Properties (Setters)</h3>

 <p>You can also define what Ember should do when setting a computed
 property. If you try to set a computed property, it will be invoked with
 the key and value you want to set it to.</p>

 <pre><code>Person = SC.Object.extend({
   // these will be supplied by `create`
   firstName: null,
   lastName: null,

   fullName: SC.computed(function(key, value) {
     // getter
     if (value === undefined) {
       var firstName = this.get('firstName');
       var lastName = this.get('lastName');

       return firstName + ' ' + lastName;

     // setter
     } else {
       var name = value.split(" ");

       this.set('firstName', name[0]);
       this.set('lastName', name[1]);

       return value;
     }
   }).property('firstName', 'lastName')
 });

 var person = Person.create();
 person.set('name', "Peter Wagenet");
 person.get('firstName') // Peter
 person.get('lastName') // Wagenet
 </code></pre>

 <p>Ember will call the computed property for both setters and getters, and
 you can check the <code>value</code> to determine whether it is being called as a
 getter or a setter.</p>

 <h3>Observers</h3>

 <p>Ember supports observing any property, including computed properties.
 You can set up an observer on an object by using the <code>addObserver</code>
 method.</p>

 <pre><code>Person = SC.Object.extend({
   // these will be supplied by `create`
   firstName: null,
   lastName: null,

   fullName: SC.computed(function() {
     var firstName = this.get('firstName');
     var lastName = this.get('lastName');

     return firstName + ' ' + lastName;
   }).property('firstName', 'lastName')
 });

 var person = Person.create
   firstName: "Yehuda",
   lastName: "Katz"
 });

 person.addObserver('fullName', function() {
   // deal with the change
 });

 person.set('firstName', "Brohuda"); // observer will fire
 </code></pre>

 <p>Because the <code>fullName</code> computed property depends on <code>firstName</code>,
 updating <code>firstName</code> will fire observers on <code>fullName</code> as well.</p>

 <p>Because observers are so common, Ember provides a way to define
 observers inline in class definitions.</p>

 <pre><code>Person.reopenClass({
   fullNameChanged: function() {
     // this is an inline version of .addObserver
   }.observes('fullName')
 });
 </code></pre>

 <p>You can define inline observers by using the <code>SC.observer</code> method if you
 are using Ember without prototype extensions:</p>

 <pre><code>Person.reopenClass({
   fullNameChanged: SC.observer(function() {
     // this is an inline version of .addObserver
   }, 'fullName')
 });
 </code></pre>

 <h3>Bindings</h3>

 <p>A binding creates a link between two properties such that when one changes, the
 other one is updated to the new value automatically. Bindings can connect
 properties on the same object, or across two different objects. Unlike most other
 frameworks that include some sort of binding implementation, bindings in
 Ember.js can be used with any object, not just between views and models.</p>

 <p>The easiest way to create a two-way binding is by creating a new property
 with the string <code>Binding</code> at the end, then specifying a path from the global scope:</p>

 <pre><code>App.wife = SC.Object.create({
   householdIncome: 80000
 });

 App.husband = SC.Object.create({
   householdIncomeBinding: 'App.wife.householdIncome'
 });

 App.husband.get('householdIncome'); // 80000

 // Someone gets raise.
 App.husband.set('householdIncome', 90000);
 App.wife.get('householdIncome'); // 90000
 </code></pre>

 <p>  App.user = SC.Object.create({</p>

 <pre><code>fullName: "Kara Gates"
 </code></pre>

 <p>  });</p>

 <p>Note that bindings don&rsquo;t update immediately. Ember waits until all of your
 application code has finished running before synchronizing changes, so you can change a bound property as many times as you&rsquo;d like without worrying about the overhead of syncing bindings
 when values are transient.</p>

 <h4>One-Way Bindings</h4>

 <p>A one-way binding only propagates changes in one direction. Usually, one-way
 bindings are just a performance optimization and you can safely use
 the more concise two-way binding syntax (as, of course, two-way bindings are
 de facto one-way bindings if you only ever change one side).</p>

 <pre><code>App.user = SC.Object.create({
   fullName: "Kara Gates"
 });

 App.userView = SC.View.create({
   userNameBinding: SC.Binding.oneWay('App.user.fullName')
 });

 // Changing the name of the user object changes
 // the value on the view.
 App.user.set('fullName', "Krang Gates");
 // App.userView.fullName will become "Krang Gates"

 // ...but changes to the view don't make it back to
 // the object.
 App.userView.set('fullName', "Truckasaurus Gates");
 // App.user.fullName will still be "Krang Gates"
 </code></pre>

 <h3>What Do I Use When?</h3>

 <p>Sometimes new users are confused about when to use computed properties,
 bindings and observers. Here are some guidelines to help:</p>

 <ol>
 <li><p>Use <em>computed properties</em> to build a new property by synthesizing other
 properties. Computed properties should not contain application behavior, and
 should generally not cause any side-effects when called. Except in rare cases,
 multiple calls to the same computed property should always return the same
 value (unless the properties it depends on have changed, of course.)</p></li>
 <li><p><em>Observers</em> should contain behavior that reacts to changes in another
 property. Observers are especially useful when you need to perform some
 behavior after a binding has finished synchronizing.</p></li>
 <li><p><em>Bindings</em> are most often used to ensure objects in two different layers
 are always in sync. For example, you bind your views to your controller using
 Handlebars. You may often bind between two objects in the same for layer. For
 example, you might have an <code>App.selectedContactController</code> that binds to the
 <code>selectedContact</code> property of <code>App.contactsController</code>.</p></li>
 </ol>
</div>

<div class="section">
 <h2>Describing Your UI with Handlebars</h2>

 <p>Unlike other frameworks that require you to have separate code paths for first generating your user interface and then updating it when parts change, Amber.js augments the Handlebars templating library to perform all of these updates for you.</p>

 <p>With Amber, you describe your interface using a template. The framework takes care of ensuring that the template is converted to HTML and placed in the DOM. And, because the templates are bindings-aware, if any of the data underlying your template changes, your template will re-render just the changed portion and update the DOM automatically, without you having to write a single line of code.</p>

 <h3>Handlebars</h3>

 <p>SproutCore comes bundled with <a href="http://www.handlebarsjs.com">Handlebars</a>, a semantic templating language. These templates look like regular HTML, with embedded expressions.</p>

 <p>You should store your Handlebars templates inside your application&rsquo;s HTML file. At runtime, SproutCore will compile these templates so they are available for you to use in your views.</p>

 <p>To immediately insert a template into your document, place it inside a <code>&lt;script&gt;</code> tag within your <code>&lt;body&gt;</code> tag:</p>

 <pre>
 &lt;html>
     &lt;body>
         &lt;script type="text/x-handlebars">
             Hello, &lt;b>{{MyApp.name}}&gt;/b>
         &lt;/script>
     &lt;/body>
 &lt;/html>
 </pre>


 <p>To make a template available to be used later, give the <code>&lt;script&gt;</code> tag a name attribute:</p>

 <pre>
     &lt;html>
         &lt;head>
             &lt;script type="text/x-handlebars" data-template-name="say-hello">
                 Hello, &lt;b>{{MyApp.name}}&gt;/b>
             &lt;/script>
         &lt;/head>
     &lt;/html>
 </pre>


 <h3>Am.View</h3>

 <p>You can use Am.View to render a Handlebars template and insert it into the DOM.</p>

 <p>To tell the view which template to use, set its +templateName+ property. For example, if I had a million dollars...</p>

 </div>
 </body>
 </html>

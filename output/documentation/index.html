<!DOCTYPE html>
<html lang="en">
<head>
<title>Ember.js - Documentation</title>
<link rel=stylesheet href="/styles/documentation.css" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27488933-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	<link type="text/css" rel="stylesheet" href="/styles/shCoreDefault.css"/>
</head>

<body>
<div id="wrap">
<div id="about">
	<div id="logo">&nbsp;</div>
	<p>
	  Ember is a JavaScript framework that helps developers be more productive by eliminating boilerplate and providing a strong MVC architecture.
	</p>
	<a class="button">download</a>
	<ul id="nav">
		<li><a href="index.html">tutorial</a></li>
		<li class="active"><a href="/docs.html">docs</a></li>
	</ul>
</div>

<div id="content">
  <div class="section">
  <h2>Introduction</h2>

<h3>What is Ember.js?</h3>

<p>Ember is a JavaScript framework that helps developers be more productive
by eliminating boilerplate and providing a strong MVC architecture.</p>

<h4>Eliminate Boilerplate</h4>

<p>There are some tasks that are common to every web application. For example,
taking data from the server, rendering it to the screen, then updating that
information when it changes.</p>

<p>Since the tools provided to do this by the browser are quite primitive, you
end up writing the same code over and over. Ember.js provides tools that let
you focus on your app instead of writing the same code you&#39;ve written a hundred
times.</p>

<p>Because we&#39;ve built dozens of applications ourselves, we&#39;ve gone beyond the
obvious low-level event-driven abstractions, eliminating much of the
boilerplate associated with propagating changes throughout your application,
and especially into the DOM itself.</p>

<p>To help manage changes in the view, Ember.js comes with a templating engine
that will automatically update the DOM when the underlying objects change.</p>

<p>For a simple example, consider this template of a Person:</p>

<pre class="brush: xml">
{{person.name}} is {{person.age}}.
</pre>

<p>As with any templating system, when the template is initially rendered, it
will reflect the current state of the person. To avoid boilerplate, though,
Ember.js will also update the DOM automatically for you if the person&#39;s name
or age changes.</p>

<p>You specify your template once, and Ember.js makes sure it&#39;s always up to date.</p>

<h4>Provides Architecture</h4>

<p>Since web applications evolved from web pages, which were nothing more than
static documents, browsers give you just enough rope to hang yourself with.</p>

<p>Ember makes it easy to divide your application into models, views, and controllers,
which improves testability, makes code more modular, and helps new developers
on the project quickly understand how everything fits together. The days of
callback spaghetti are over.</p>

<p>Ember also supplies built-in support for state management, so you&#39;ll have
a way to describe how your application moves through various nested states
(like signed-out, signed-in, viewing-post, and viewing-comment) out of the box.</p>

<p><we will eventually want a paragraph about data here></p>

<h3>How is Ember.js Different from Server-Side Frameworks?</h3>

<p>Traditional web applications make the user to download a new page every time
they interact with the server. This means that every interaction is never faster
than the latency between you and the user, and usually slower. Using AJAX to
replace only parts of the page helps somewhat, but still requires a roundtrip to
your server every time your UI needs to update. And if multiple parts of the
page need to update all at once, most developers just resort to loading the page
over again, since keeping everything in sync is tricky.</p>

<p>Ember.js, like some other modern JavaScript frameworks, works a little differently.
Instead of the majority of your application&#39;s logic living on the server, an
Ember.js application downloads everything it needs to run in the initial page
load. That means that while your user is using your app, she never has to load
a new page and your UI responds quickly to their interaction.</p>

<p>One advantage of this architecture is that your web application uses the same
REST API as your native apps or third-party clients. Back-end developers can
focus on building a fast, reliable, and secure API server, and don&#39;t have to be
front-end experts, too.</p>

<h3>Ember.js at a Glance</h3>

<p>These are the three features that make Ember a joy to use:</p>

<ol>
<li>Bindings</li>
<li>Computed properties</li>
<li>Auto-updating templates</li>
</ol>

<h4>Bindings</h4>

<p>Use bindings to keep properties between two different objects in sync. You just
declare a binding once, and Ember will make sure changes get propagated in either
direction.</p>

<p>Here&#39;s how you create a binding between two objects:</p>

<pre class="brush: js;">
MyApp.president = SC.Object.create({
  name: "Barack Obama"
});

MyApp.country = SC.Object.create({
  // Ending a property with 'Binding' tells Ember to
  // create a binding to the presidentName property.
  presidentNameBinding: 'MyApp.president.name'
});

MyApp.country.get('presidentName');
// "Barack Obama"
</pre>

<p>Bindings allow you to architect your application using the MVC (Model-View-Controller)
pattern, then rest easy knowing that data will always flow correctly from layer to layer.</p>

<h4>Computed Properties</h4>

<p>Computed properties allow you to treat a function like a property:</p>

<pre class="brush: js;">
MyApp.president = SC.Object.create({
  firstName: "Barack",
  lastName: "Obama",

  fullName: function() {
    return this.get('firstName') + ' ' + this.get('lastName');
  
  // Call this flag to mark the function as a property
  }.property()
});

MyApp.president.get('fullName');
// "Barack Obama"
</pre>

<p>Computed properties are useful because they can work with bindings, just
like any other property.</p>

<p>Many computed properties have dependencies on other properties. For example, in the above
example, the <code>fullName</code> property depends on <code>firstName</code> and <code>lastName</code> to determine its value.
You can tell Ember about these dependencies like this:</p>

<pre class="brush: js;">
MyApp.president = SC.Object.create({
  firstName: "Barack",
  lastName: "Obama",

  fullName: function() {
    return this.get('firstName') + ' ' + this.get('lastName');

  // Tell Ember that this computed property depends on firstName
  // and lastName
  }.property('firstName', 'lastName')
});
</pre>

<p>Make sure you list these dependencies so Ember knows when to update bindings that connect
to a computed property.</p>

<h3>Auto-updating Templates</h3>

<p>Ember uses Handlebars, a semantic templating library. To take data from your JavaScript application
and put it into the DOM, create a <code>&lt;script&gt;</code> tag and put it into your HTML, wherever you&#39;d like the
value to appear:</p>

<pre class="brush: xml">
&lt;script type="text/x-handlebars">
  The President of the United States is {{MyApp.president.fullName}}.
&lt;/script>
</pre>

<p>Here&#39;s the best part: templates are bindings-aware. That means that if you ever change the value of
the property that you told us to display, we&#39;ll update it for you automatically. And because you&#39;ve
specified dependencies, changes to <em>those</em> properties are reflected as well.</p>

<p>Hopefully you can see how all three of these powerful tools work together: start with some primitive
properties, then start building up more sophisticated properties and their dependencies using computed
properties. Once you&#39;ve described the data, you only have to say how it gets displayed once, and Ember
takes care of the rest. It doesn&#39;t matter how the underlying data changes, whether from an XHR request
or the user performing an action; your user interface always stays up-to-date. This eliminates entire
categories of edge cases that developers struggle with every day.</p>

</div>
<div class="section">
  <h2>The Ember Object Model</h2>

<p>Ember enhances the simple JavaScript object model to support bindings
and observers, as well as to support a more powerful mixin-based
approach to code sharing.</p>

<p>At its most basic, you create a new Ember class by using the <code>extend</code>
method on <code>SC.Object</code>.</p>

<p><code>javascript
Person = SC.Object.extend({
  say: function(thing) {
    alert(thing);
 }
});
</code></p>

<p>Once you have built a new class, you can create new instances of the
class by using the <code>create</code> method. Any properties defined on the class
will be available to instances.</p>

<p><code>javascript
var person = Person.create();
person.say(&quot;Hello&quot;) &#47;&#47; alerts &quot;Hello&quot;
</code></p>

<p>When creating an instance, you can also add additional properties to the
class by passing in an object.</p>

<p>```javascript
var tom = Person.create({
  name: &quot;Tom Dale&quot;,</p>

<p>helloWorld: function() {
    this.say(&quot;Hi my name is &quot; + this.get(&#39;name&#39;));
  }
});</p>

<p>tom.helloWorld() &#47;&#47; alerts &quot;Hi my name is Tom Dale&quot;
```</p>

<p>Because of Ember&#39;s support for bindings and observers, you will always
access properties using the <code>get</code> method, and set properties using the
<code>set</code> method.</p>

<p>When creating a new instance of an object, you can also override any
properties or methods defined on the class. For instance, in this case,
you could override the <code>say</code> method from the <code>Person</code> class.</p>

<p>```javascript
var yehuda = Person.create({
  name: &quot;Yehuda Katz&quot;,</p>

<p>say: function(thing) {
    var name = this.get(&#39;name&#39;);</p>

<pre><code>this._super(name + &quot; says: &quot; + thing);
</code></pre>

<p>}
});
```</p>

<p>You can use the <code>_super</code> method on the object (<code>super</code> is a reserved
word in JavaScript) to call the original method you overrode.</p>

<h3>Subclassing Classes</h3>

<p>You can also create subclasses of classes you create by using the
<code>extend</code> method. In fact, when we created a new class above by calling
<code>extend</code> on <code>SC.Object</code>, we were <strong>subclassing</strong> <code>SC.Object</code>.</p>

<p><code>javascript
var LoudPerson = Person.extend({
  say: function(thing) {
    this._super(thing.toUpperCase());
  }
});
</code></p>

<p>When subclassing, you can use <code>this._super</code> to invoke methods you are
overriding.</p>

<h3>Reopening Classes</h3>

<p>You don&#39;t need to define a class all at once. You can reopen a class and
define new properties using the <code>reopenClass</code> method.</p>

<p>```javascript
Person.reopenClass({
  isPerson: true
});</p>

<p>Person.create().get(&#39;isPerson&#39;) &#47;&#47; true
```</p>

<p>When using <code>reopenClass</code>, you can also override existing methods and
call <code>this._super</code>.</p>

<p><code>javascript
Person.reopenClass({
  &#47;&#47; override `say` to add an ! at the end
  say: function(thing) {
    this._super(thing + &quot;!&quot;);
  }
});
</code></p>

<h3>Computed Properties (Getters)</h3>

<p>Often, you will want a property that is computed based on other
properties. Ember&#39;s object model allows you to define computed
properties easily in a normal class definition.</p>

<p>``<code>javascript
Person = SC.Object.extend({
  &#47;&#47; these will be supplied by</code>create`
  firstName: null,
  lastName: null,</p>

<p>fullName: function() {
    var firstName = this.get(&#39;firstName&#39;);
    var lastName = this.get(&#39;lastName&#39;);</p>

<p>return firstName + &#39; &#39; + lastName;
  }.property(&#39;firstName&#39;, &#39;lastName&#39;)
});</p>

<p>var tom = Person.create({
  firstName: &quot;Tom&quot;,
  lastName: &quot;Dale&quot;
});</p>

<p>tom.get(&#39;fullName&#39;) &#47;&#47; &quot;Tom Dale&quot;
```</p>

<p>If you aren&#39;t using Ember&#39;s prototype extensions, you can use a slightly
more verbose version, wrapping the function in a call to <code>SC.computed</code>:</p>

<p>``<code>javascript
Person = SC.Object.extend({
  &#47;&#47; these will be supplied by</code>create`
  firstName: null,
  lastName: null,</p>

<p>fullName: SC.computed(function() {
    var firstName = this.get(&#39;firstName&#39;);
    var lastName = this.get(&#39;lastName&#39;);</p>

<pre><code>return firstName + &#39; &#39; + lastName;
</code></pre>

<p>}).property(&#39;firstName&#39;, &#39;lastName&#39;)
});
```</p>

<p>The <code>property</code> method defines the function as a computed property, and
defines its dependencies. Those dependencies will come into play later
when we discuss bindings and observers.</p>

<p>When subclassing a class or creating a new instance, you can override
any computed properties.</p>

<h3>Computed Properties (Setters)</h3>

<p>You can also define what Ember should do when setting a computed
property. If you try to set a computed property, it will be invoked with
the key and value you want to set it to.</p>

<p>``<code>javascript
Person = SC.Object.extend({
  &#47;&#47; these will be supplied by</code>create`
  firstName: null,
  lastName: null,</p>

<p>fullName: SC.computed(function(key, value) {
    &#47;&#47; getter
    if (arguments.length === 1) {
      var firstName = this.get(&#39;firstName&#39;);
      var lastName = this.get(&#39;lastName&#39;);</p>

<pre><code>  return firstName + &#39; &#39; + lastName;

&#47;&#47; setter
} else {
  var name = value.split(&quot; &quot;);

  this.set(&#39;firstName&#39;, name[0]);
  this.set(&#39;lastName&#39;, name[1]);

  return value;
}
</code></pre>

<p>}).property(&#39;firstName&#39;, &#39;lastName&#39;)
});</p>

<p>var person = Person.create();
person.set(&#39;name&#39;, &quot;Peter Wagenet&quot;);
person.get(&#39;firstName&#39;) &#47;&#47; Peter
person.get(&#39;lastName&#39;) &#47;&#47; Wagenet
```</p>

<p>Ember will call the computed property for both setters and getters, and
you can check the number of arguments to determine whether it is being called
as a getter or a setter.</p>

<h3>Observers</h3>

<p>Ember supports observing any property, including computed properties.
You can set up an observer on an object by using the <code>addObserver</code>
method.</p>

<p>``<code>javascript
Person = SC.Object.extend({
  &#47;&#47; these will be supplied by</code>create`
  firstName: null,
  lastName: null,</p>

<p>fullName: SC.computed(function() {
    var firstName = this.get(&#39;firstName&#39;);
    var lastName = this.get(&#39;lastName&#39;);</p>

<pre><code>return firstName + &#39; &#39; + lastName;
</code></pre>

<p>}).property(&#39;firstName&#39;, &#39;lastName&#39;)
});</p>

<p>var person = Person.create
  firstName: &quot;Yehuda&quot;,
  lastName: &quot;Katz&quot;
});</p>

<p>person.addObserver(&#39;fullName&#39;, function() {
  &#47;&#47; deal with the change
});</p>

<p>person.set(&#39;firstName&#39;, &quot;Brohuda&quot;); &#47;&#47; observer will fire
```</p>

<p>Because the <code>fullName</code> computed property depends on <code>firstName</code>,
updating <code>firstName</code> will fire observers on <code>fullName</code> as well.</p>

<p>Because observers are so common, Ember provides a way to define
observers inline in class definitions.</p>

<p><code>javascript
Person.reopenClass({
  fullNameChanged: function() {
    &#47;&#47; this is an inline version of .addObserver
  }.observes(&#39;fullName&#39;)
});
</code></p>

<p>You can define inline observers by using the <code>SC.observer</code> method if you
are using Ember without prototype extensions:</p>

<p><code>javascript
Person.reopenClass({
  fullNameChanged: SC.observer(function() {
    &#47;&#47; this is an inline version of .addObserver
  }, &#39;fullName&#39;)
});
</code></p>

<h3>Bindings</h3>

<p>A binding creates a link between two properties such that when one changes, the
other one is updated to the new value automatically. Bindings can connect
properties on the same object, or across two different objects. Unlike most other
frameworks that include some sort of binding implementation, bindings in
Ember.js can be used with any object, not just between views and models.</p>

<p>The easiest way to create a two-way binding is by creating a new property
with the string <code>Binding</code> at the end, then specifying a path from the global scope:</p>

<p>```javascript
App.wife = SC.Object.create({
  householdIncome: 80000
});</p>

<p>App.husband = SC.Object.create({
  householdIncomeBinding: &#39;App.wife.householdIncome&#39;
});</p>

<p>App.husband.get(&#39;householdIncome&#39;); &#47;&#47; 80000</p>

<p>&#47;&#47; Someone gets raise.
App.husband.set(&#39;householdIncome&#39;, 90000);
App.wife.get(&#39;householdIncome&#39;); &#47;&#47; 90000
```</p>

<p>Note that bindings don&#39;t update immediately. Ember waits until all of your
application code has finished running before synchronizing changes, so you can
change a bound property as many times as you&#39;d like without worrying about the
overhead of syncing bindings when values are transient.</p>

<h4>One-Way Bindings</h4>

<p>A one-way binding only propagates changes in one direction. Usually, one-way
bindings are just a performance optimization and you can safely use
the more concise two-way binding syntax (as, of course, two-way bindings are
de facto one-way bindings if you only ever change one side).</p>

<p>```javascript
App.user = SC.Object.create({
  fullName: &quot;Kara Gates&quot;
});</p>

<p>App.userView = SC.View.create({
  userNameBinding: SC.Binding.oneWay(&#39;App.user.fullName&#39;)
});</p>

<p>&#47;&#47; Changing the name of the user object changes
&#47;&#47; the value on the view.
App.user.set(&#39;fullName&#39;, &quot;Krang Gates&quot;);
&#47;&#47; App.userView.fullName will become &quot;Krang Gates&quot;</p>

<p>&#47;&#47; ...but changes to the view don&#39;t make it back to
&#47;&#47; the object.
App.userView.set(&#39;fullName&#39;, &quot;Truckasaurus Gates&quot;);
App.user.get(&#39;fullName&#39;); &#47;&#47; &quot;Krang Gates&quot;
```</p>

<h3>What Do I Use When?</h3>

<p>Sometimes new users are confused about when to use computed properties,
bindings and observers. Here are some guidelines to help:</p>

<ol>
<li><p>Use <em>computed properties</em> to build a new property by synthesizing other
properties. Computed properties should not contain application behavior, and
should generally not cause any side-effects when called. Except in rare cases,
multiple calls to the same computed property should always return the same
value (unless the properties it depends on have changed, of course.)</p></li>
<li><p><em>Observers</em> should contain behavior that reacts to changes in another
property. Observers are especially useful when you need to perform some
behavior after a binding has finished synchronizing.</p></li>
<li><p><em>Bindings</em> are most often used to ensure objects in two different layers
are always in sync. For example, you bind your views to your controller using
Handlebars. You may often bind between two objects in the same for layer. For
example, you might have an <code>App.selectedContactController</code> that binds to the
<code>selectedContact</code> property of <code>App.contactsController</code>.</p></li>
</ol>

</div>

</div>
<script type="text/javascript" src="/scripts/shCore.js"></script>
<script type="text/javascript" src="/scripts/shBrushJScript.js"></script>
<script type="text/javascript" src="/scripts/shBrushXml.js"></script>
<script type="text/javascript">
  SyntaxHighlighter.defaults.toolbar = false;
  SyntaxHighlighter.all();
</script>
</body>
</html>
